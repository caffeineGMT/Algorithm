<!doctype html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Java Learning
    by Maitao Guo</title>
  <!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Java Learning" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="by Maitao Guo" />
<meta property="og:description" content="by Maitao Guo" />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="Java Learning" />
<script type="application/ld+json">
{"url":"http://localhost:4000/","headline":"Java Learning","name":"Java Learning","description":"by Maitao Guo","@type":"WebSite","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/css/style.css?v=d8fd6fe9343eef8c26cea21b4607534c13be4f0c">
  <script src="https://code.jquery.com/jquery-3.3.0.min.js"
    integrity="sha256-RTQy8VOmNlT6b2PIRur37p6JEBZUE7o8wPgMvu18MC4=" crossorigin="anonymous"></script>
  <script src="/assets/js/main.js"></script>
  <!--[if lt IE 9]>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" integrity="sha256-3Jy/GbSLrg0o9y5Z5n1uw0qxZECH7C6OQpVBgNFYa0g=" crossorigin="anonymous"></script>
    <![endif]-->
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <style>
    body {
      background: {
          {
          page.pg_bk_color
        }
      }

      ;
    }

    header {
      background: {
          {
          page.header_bk_color
        }
      }

      ;
    }

    a {
      color: {
          {
          page.link_color
        }
      }

      ;
    }
  </style>
</head>

<body>

  <header>
    
    <h1>Java Learning</h1>
    <p>by Maitao Guo</p>
    
  </header>

  <div id="banner">
    <span id="logo"></span>

    <a href="https://github.com/caffeineGMT/Algorithm" class="button fork"><strong>View On GitHub</strong></a>
    
  </div><!-- end banner -->

  <div class="wrapper">
    <nav>
      <ul></ul>
    </nav>
    <section>
      <!-- markdownlint-disable MD025-->

<h1 id="algorithm-note">Algorithm Note</h1>

<p>This is a repo recording any important note or thought when learning Algorithm. Most of the note/solution will be based on MOOC course “Code with Mosh” Algorithm Series.</p>

<h1 id="undirected-graph">Undirected Graph</h1>

<p>-</p>

<h1 id="graph">Graph</h1>

<ul>
  <li>app: network connection, social media, path finding</li>
  <li>basic concept:
    <ul>
      <li>vertex: V/n</li>
      <li>edge: E/m</li>
      <li>incident edges: immediate edges connecting to a node</li>
      <li>degree of node: how many incident node</li>
      <li>adjacent node/vertices</li>
      <li>path: sequence of vertices connect by edges</li>
      <li>cycle: path with a common start and end</li>
      <li>simple graph: no self loop or multi-edges</li>
      <li>directed graph</li>
      <li>undirected graph</li>
    </ul>
  </li>
  <li>edges numbers:
    <ul>
      <li>min edges for a graph:
        <ul>
          <li>not connected:0</li>
          <li>connected: n-1</li>
        </ul>
      </li>
      <li>max edges for a graph:
        <ul>
          <li>simple: n*(n-1)</li>
          <li>not simple:infinity</li>
        </ul>
      </li>
      <li>sum of degree in a graph: 2m (because every inbound edge will have a corresponding outbound edge)</li>
    </ul>
  </li>
  <li>edge list(simple graph):one hash table maintain node, one hash table maintain edges</li>
</ul>

<table>
  <thead>
    <tr>
      <th>operation</th>
      <th>time complexity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>space</td>
      <td>O(n+m)(n node in hash table &amp; total m edges in hash table)</td>
    </tr>
    <tr>
      <td>insertVertex(K key)</td>
      <td>O(1)(hash table lookup)</td>
    </tr>
    <tr>
      <td>removeVertex(Vertex v)</td>
      <td>O(m)(hash table lookup, walk thru every edge)</td>
    </tr>
    <tr>
      <td>areAdjacent(Vertex v1, Vertex v2)</td>
      <td>O(m)(walk thru every edge)</td>
    </tr>
    <tr>
      <td>incidentEdges(Vertex)</td>
      <td>O(m)(hash table lookup, walk thru every edge)</td>
    </tr>
    <tr>
      <td>addEdge</td>
      <td>O(1)(hash table lookup)</td>
    </tr>
    <tr>
      <td>removeEdge</td>
      <td>O(1)(hash table lookup)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>adjacency matrix(simple graph):one hash table maintain node, one 2D array maintain edges</li>
</ul>

<table>
  <thead>
    <tr>
      <th>operation</th>
      <th>time complexity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>space</td>
      <td>O(n^2)(n node in hash table &amp; n by n 2D matrix)</td>
    </tr>
    <tr>
      <td>insertVertex(K key)</td>
      <td>O(n^2)(need to copy the whole matrix)</td>
    </tr>
    <tr>
      <td>removeVertex(Vertex v)</td>
      <td>O(n^2)(need to shrink the whole matrix)</td>
    </tr>
    <tr>
      <td>areAdjacent(Vertex v1, Vertex v2)</td>
      <td>O(1)(hash table lookup)</td>
    </tr>
    <tr>
      <td>incidentEdges(Vertex)</td>
      <td>O(n)(hash table look up &amp; walk down one row/column)</td>
    </tr>
    <tr>
      <td>addEdge</td>
      <td>O(1)(hash table lookup,turn 0 to 1)</td>
    </tr>
    <tr>
      <td>removeEdge</td>
      <td>O(1)(hash table lookup,turn 1 to 0)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>adjacency list(simple graph):one hash table maintain node, one array of linked list maintain edges</li>
</ul>

<table>
  <thead>
    <tr>
      <th>operation</th>
      <th>time complexity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>space</td>
      <td>O(n+m)(n node in hash table &amp; m edges in linked list)</td>
    </tr>
    <tr>
      <td>insertVertex(K key)</td>
      <td>O(1)(hash table lookup)</td>
    </tr>
    <tr>
      <td>removeVertex(Vertex v)</td>
      <td>O(deg(V))(hash table lookup, link lookup, relink)</td>
    </tr>
    <tr>
      <td>areAdjacent(Vertex v1, Vertex v2)</td>
      <td>O(min(deg(V1),deg(V2)))(hash table lookup, link lookup)</td>
    </tr>
    <tr>
      <td>incidentEdges(Vertex)</td>
      <td>O(deg(V))(hash table lookup, link lookup)</td>
    </tr>
    <tr>
      <td>addEdge</td>
      <td>O(deg(V))(hash table lookup, check duplicates, add link)</td>
    </tr>
    <tr>
      <td>removeEdge</td>
      <td>O(deg(V))(hash table lookup, link lookup)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>for dense graph, try to use adjacency matrix, otherwise use adjacency list</li>
</ul>

<h1 id="tries">Tries</h1>

<h1 id="heaps">Heaps</h1>

<ul>
  <li>requirement:
    <ul>
      <li>complete tree:</li>
      <li>heap property</li>
    </ul>
  </li>
  <li>type:max heap, min heap,binary heap</li>
  <li>app:heapSort;shortest path;priority queue;finding Kth smallest/largest value</li>
</ul>

<h1 id="avl-tree">AVL Tree</h1>

<h1 id="tree">Tree</h1>

<p>good binary search tree:
| insert | lookup | delete |
| ——– | ——– | ——– |
| O(log n) | O(log n) | O(log n) |</p>

<p>bad tree:
| insert | lookup | delete |
| ——– | ——– | ——– |
| O(log n) | O(log n) | O(log n) |</p>

<ul>
  <li>app: representing hierarchical data, databases, autocompletion, compilers, compression</li>
  <li>BST cannot have duplicated value inside true, the child is either smaller or larger than parent node, cannot be equal.</li>
  <li>traversal:
    <ul>
      <li>Breadth First</li>
      <li>Depth First:
        <ul>
          <li>pre-order(root,left,right), walk thru parent first, then its leaf nodes</li>
          <li>in-order(left,root,right): the traversal result is incremental/decremental</li>
          <li>post-order(left,right,root): walk thru leaf node first, then its parent</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>depth and height:</p>

    <ul>
      <li>depth of node: calculating the number of edges for a node from top-down</li>
      <li>height of sub tree: calculating the number of edges for a node from bottom-up</li>
    </ul>
  </li>
</ul>

<h1 id="hash-table">Hash Table</h1>

<table>
  <thead>
    <tr>
      <th>insert</th>
      <th>lookup</th>
      <th>delete</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>app: spell checker,dictionary, compiler, code editor</li>
  <li>worst case: O(n)</li>
</ul>

<h1 id="queue">Queue</h1>

<table>
  <thead>
    <tr>
      <th>enqueue</th>
      <th>dequeue</th>
      <th>peek</th>
      <th>inEmpty</th>
      <th>isFull</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>app: printer,operating system, web servers, live support system</li>
</ul>

<h1 id="stack">Stack</h1>

<table>
  <thead>
    <tr>
      <th>push</th>
      <th>pop</th>
      <th>peek</th>
      <th>isEmpty</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>app: undo feature, syntax checking in compiler, evaluate math expression, build navigation(forward/back)</li>
  <li>can be implemented by array, arraylist or linked list internally</li>
</ul>

<h1 id="linked-list">Linked List</h1>

<table>
  <thead>
    <tr>
      <th>lookup</th>
      <th>insert</th>
      <th>delete</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>index: O(n) value:O(n)</td>
      <td>start:O(1) middle: O(n) end: O(1)</td>
      <td>singly:O(n) doubly:O(1)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>LinkedList from java.util package could be <code class="highlighter-rouge">LinkedList generic = new LinkedList();</code>. In this case, one node could host String, another node could host Integer</li>
  <li>type:
    <ul>
      <li>singly: O(n) on deleting the end item</li>
      <li>doubly: O(1) on deleting the end item</li>
      <li>circular: song playlist loop,</li>
    </ul>
  </li>
</ul>

<h1 id="array">Array</h1>

<table>
  <thead>
    <tr>
      <th>lookup by index</th>
      <th>lookup by value</th>
      <th>insert</th>
      <th>delete</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>worst:O(n) best:O(1)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>ArrayList: grow 50% everytime it’s full. not synchronized, multi thread</li>
  <li>Vector: grow 100% everytime it’s full. synchronize, single thread</li>
</ul>

<h1 id="big-o-notation">Big O notation</h1>

<ul>
  <li>runtime complexity: O(1),O(n),O(n^2),O(log n), O(2^n)</li>
  <li>space complexity: always look at additional space needs to be allocated, don’t count size of the input</li>
</ul>


    </section>
    <footer>
      
      <p>Project maintained by <a href="https://github.com/caffeineGMT">caffeineGMT</a></p>
      
      <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/mattgraham">mattgraham</a></small>
      </p>
    </footer>
  </div>

  
  <script>
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date();
      a = s.createElement(o),
        m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-121627234-4', 'auto');
    ga('send', 'pageview');
  </script>
  
</body>

</html>